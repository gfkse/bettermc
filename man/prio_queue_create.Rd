% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prio_queue.R
\name{prio_queue_create}
\alias{prio_queue_create}
\alias{prio_queue_insert}
\alias{prio_queue_release}
\alias{prio_queue_destroy}
\title{Priority Queues}
\usage{
prio_queue_create(
  ncpu = parallel::detectCores(),
  nprio = 1L,
  seconds2block = 0L
)

prio_queue_insert(pq, prio)

prio_queue_release(pq)

prio_queue_destroy(pq)
}
\arguments{
\item{ncpu}{the CPU limit to be imposed by the queue.}

\item{nprio}{the number priority levels to be supported by the queue.}

\item{seconds2block}{the number of seconds to block the queue after its
creation. This can be used to ensure that the queue is properly filled
before scheduling the first processes according to their priority. Only
supported on Linux, i.e. \code{seconds2block} must be 0 on macOS (and
Solaris).}

\item{pq}{an object as returned by \code{prio_queue_create}.}

\item{prio}{the priority of the current process, i.e. an integer between 1
and \code{nprio}. Lower values indicate higher priority.}
}
\description{
Create and destroy priority queues to be passed to \code{\link{mclapply}} as
argument \code{mc.prio.queue}. \code{prio_queue_insert} and
\code{prio_queue_release} are used internally by \code{\link{mclapply}} to
claim and release CPU units. See the examples for more details.
}
\details{
The core of the queue is implemented using a set of \code{nprio + 1}
  System V semaphores. One semaphore holds the currently available CPU units,
  while the others are used to record the queue lengths for the different
  priorities. Note that different operating systems impose different limits
  w.r.t. System V semaphores. In particular, SEMVMX (the maximum value for a
  semaphore) hence limits both \code{ncpu} and the number of processes which
  can be queued per priority. On Linux, SEMVMX is 32,767.

  The initial blocking is implemented using an unnamed POSIX semaphore and a
  POSIX timer, which macOS both lacks support for.
}
\note{
A priority queue should be destroyed explicitly after use to release
  the associated resources by calling \code{prio_queue_destroy}. It is
  undefined behavior to destroy a queue which is still in use or to call
  \code{prio_queue_destroy} multiple times on the same queue.

  The number of calls in a process to \code{prio_queue_release} must not
  exceed the number of previous call to \code{prio_queue_insert}. Otherwise
  undefined behavior results. Calls to \code{prio_queue_release} might be
  omitted. In this case, release of previously claimed but not yet released
  CPU units happens on process termination.
}
\section{Windows Support}{
 Not supported on Windows.
}

\section{Lifecycle}{

  \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options:
  alt='[Experimental]'}}}{\strong{[Experimental]}}
}

\examples{
\donttest{
# interactive() just to make R CMD check on CRAN skip checking this example
# because it creates more processes than allowed
if (interactive() & bettermc:::OSTYPE != "windows") {
  x <- 1:4
  y <- 1:5

  ncpu <- 4
  nprio <- 3
  seconds2block = if (bettermc:::OSTYPE == "linux") 1 else 0

  pq <- bettermc::prio_queue_create(ncpu = ncpu, nprio = nprio,
                                    seconds2block = seconds2block)

  res <- bettermc::mclapply(x, function(i) {
    # determine priorities of child processes to be created
    priorities <- sample(nprio, length(y), replace = TRUE)

    bettermc::mclapply(y, function(j) {
      # do some work
      cat(sprintf("(\%s) priority: \%d (pid :\%d)\n",
                  as.character(Sys.time()), priorities[j], Sys.getpid()))
      Sys.sleep(1)
    },
    mc.cores = length(y), mc.prio.queue = pq, mc.priority = priorities,
    mc.stdout = "output", mc.progress = FALSE)
  },
  mc.cores = length(x), mc.progress = FALSE)

  bettermc::prio_queue_destroy(pq)

  # the above is roughly equivalent to the following more manual approach
  pq <- bettermc::prio_queue_create(ncpu = ncpu, nprio = nprio,
                                    seconds2block = seconds2block)

  res <- bettermc::mclapply(x, function(i) {
    # determine priorities of child processes to be created
    priorities <- sample(nprio, length(y), replace = TRUE)

    bettermc::mclapply(y, function(j) {
      bettermc::prio_queue_insert(pq, priorities[j])  # wait for free CPU with priority
      on.exit(bettermc::prio_queue_release(pq))  # release CPU when done

      # do some work
      cat(sprintf("(\%s) priority: \%d (pid :\%d)\n",
                  as.character(Sys.time()), priorities[j], Sys.getpid()))
      Sys.sleep(1)
    },
    mc.cores = length(y),
    mc.stdout = "output", mc.progress = FALSE)
  },
  mc.cores = length(x), mc.progress = FALSE)

  bettermc::prio_queue_destroy(pq)
}
}

}
